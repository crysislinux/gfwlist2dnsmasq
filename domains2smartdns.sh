#!/bin/sh

_green() {
    printf '\033[1;31;32m'
    printf -- "%b" "$1"
    printf '\033[0m'
}

_red() {
    printf '\033[1;31;31m'
    printf -- "%b" "$1"
    printf '\033[0m'
}

_yellow() {
    printf '\033[1;31;33m'
    printf -- "%b" "$1"
    printf '\033[0m'
}

usage() {
    cat <<-EOF

Name:        domains2smartdns.sh
Desription:  A shell script which convert domain list into smartdns rules.
Version:     0.0.1 (2021.10.16)
Author:      https://github.com/crysislinux

Usage: sh domains2smartdns.sh -s DOMAIN_FILE [options] -o FILE
Valid options are:
    -s, --source <DOMAIN_FILE>
                Domain list generated from GfwList
    -d, --dns <dns_name>
                DNS name for the GfwList Domains
    -o, --output <FILE>
                /path/to/output_filename
    -h, --help
                Usage
EOF
    exit $1
}

clean_and_exit(){
    # Clean up temp files
    printf 'Cleaning up... '
    rm -rf $TMP_DIR
    _green 'Done\n\n'
    [ $1 -eq 0 ] && _green 'Job Finished.\n\n' || _red 'Exit with Error code '$1'.\n'
    exit $1
}

check_depends(){
    which sed base64 mktemp >/dev/null
    if [ $? != 0 ]; then
        _red 'Error: Missing Dependency.\nPlease check whether you have the following binaries on you system:\nwhich, sed, base64, mktemp.\n'
        exit 3
    fi
    which curl >/dev/null
    if [ $? != 0 ]; then
        which wget >/dev/null
        if [ $? != 0 ]; then
            _red 'Error: Missing Dependency.\nEither curl or wget required.\n'
            exit 3
        fi
        USE_WGET=1
    else
        USE_WGET=0
    fi

    SYS_KERNEL=`uname -s`
    if [ $SYS_KERNEL = "Darwin"  -o $SYS_KERNEL = "FreeBSD" ]; then
        BASE64_DECODE='base64 -D'
        SED_ERES='sed -E'
    else
        BASE64_DECODE='base64 -d'
        SED_ERES='sed -r'
    fi
}

get_args(){
    DNS_NAME=''
    FILE_FULLPATH=''

    while [ ${#} -gt 0 ]; do
        case "${1}" in
            --help | -h)
                usage 0
                ;;
            --source | -s)
                DOMAIN_FILE="$2"
                shift
                ;;
            --dns | -d)
                DNS_NAME="$2"
                shift
                ;;
            --output | -o)
                OUT_FILE="$2"
                shift
                ;;
            *)
                _red "Invalid argument: $1"
                usage 1
                ;;
        esac
        shift 1
    done

    # Check source path & source file name
    if [ -z $DOMAIN_FILE ]; then
        _red 'Error: Please specify the path to the domain list file(using -s/--source argument).\n'
        exit 1
    else
        if [ -z ${DOMAIN_FILE##*/} ]; then
            _red 'Error: '$DOMAIN_FILE' is a path, not a file.\n'
            exit 1
        fi
    fi

    # Check output path & output file name
    if [ -z $OUT_FILE ]; then
        _red 'Error: Please specify the path to the output file(using -o/--output argument).\n'
        exit 1
    else
        if [ -z ${OUT_FILE##*/} ]; then
            _red 'Error: '$OUT_FILE' is a path, not a file.\n'
            exit 1
        else
            if [ ${OUT_FILE}a != ${OUT_FILE%/*}a ] && [ ! -d ${OUT_FILE%/*} ]; then
                _red 'Error: Folder do not exist: '${OUT_FILE%/*}'\n'
                exit 1
            fi
        fi
    fi
}

process(){
    # Set Global Var
    TMP_DIR=`mktemp -d /tmp/gfwlist2dnsmasq.XXXXXX`
    CONF_TMP_FILE="$TMP_DIR/gfwlist.conf.tmp"
    OUT_TMP_FILE="$TMP_DIR/gfwlist.out.tmp"

    # Convert domains into smartdns rules
    sort -u $DOMAIN_FILE | $SED_ERES 's#(.+)#nameserver /\1/'$DNS_NAME'#g' > $CONF_TMP_FILE

    # Generate output file
    echo '# smartdns rules generated by gfwlist' > $OUT_TMP_FILE
    echo "# Last Updated on $(date "+%Y-%m-%d %H:%M:%S")" >> $OUT_TMP_FILE
    echo '# ' >> $OUT_TMP_FILE
    cat $CONF_TMP_FILE >> $OUT_TMP_FILE
    cp $OUT_TMP_FILE $OUT_FILE

    cp $OUT_TMP_FILE $OUT_FILE
    printf '\nConverting GfwList to '$OUT_TYPE'... ' && _green 'Done\n\n'

    # Clean up
    clean_and_exit 0
}

main() {
    if [ -z "$1" ]; then
        usage 0
    else
        check_depends
        get_args "$@"
        _green '\nJob Started.\n\n'
        process
    fi
}

main "$@"